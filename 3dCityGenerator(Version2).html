<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Random Terrain with Labels</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <!-- Three.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
    <script src="MV.js"></script>
    <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
        }
        </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const roadColor = 0x808080; // 회색 도로 색상
        const buildingAreaColors = [0x3b5998, 0x8b9dc3, 0xdfe3ee, 0xf7f7f7]; // 건물 밀집 구역 색상
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        const sunPosition = new THREE.Vector3(1, 0, 0);
        let weatherParticles = [];
        let weatherState = 'clear';
        let directionalLight; // 여기에 추가
        // 상수 정의 추가 (파일 상단)
        const ZONE_TYPES = {
            PARK: 0,
            RESIDENTIAL: 1,
            COMMERCIAL: 2
        };

        const ZONE_COLORS = {
            [ZONE_TYPES.PARK]: 0x90EE90,        // 연한 녹색
            [ZONE_TYPES.RESIDENTIAL]: 0xFFB6C1,  // 연한 분홍색
            [ZONE_TYPES.COMMERCIAL]: 0xADD8E6    // 연한 파란색
        };
        // 텍스처 로더 추가
        const loader = new THREE.TextureLoader();


        // 텍스처 정의 부분 수정
        const groundTextures = {
            [ZONE_TYPES.PARK]: loader.load(
                'https://cdn.crowdpic.net/detail-thumb/thumb_d_E39E7BFF2375AC719A78A5F28A02CA12.jpg',
                () => console.log('Grass texture loaded successfully'),
                undefined,
                () => console.error('Error loading grass texture')
            ),
            [ZONE_TYPES.RESIDENTIAL]: loader.load(
                'https://images.unsplash.com/photo-1644924604597-373500f4cf28?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTB8fHdvb2QlMjB0ZXh0dXJlfGVufDB8fDB8fHww',
                () => console.log('Residential texture loaded successfully'),
                undefined,
                () => console.error('Error loading residential texture')
            ),
            [ZONE_TYPES.COMMERCIAL]: loader.load(
                'https://images.unsplash.com/photo-1642796013928-a61b6941db11?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTB8fGNvbmNyZXRlJTIwdGV4dHVyZXxlbnwwfHwwfHx8MA%3D%3D',
                () => console.log('Commercial texture loaded successfully'),
                undefined,
                () => console.error('Error loading commercial texture')
            )
        };
        // texture wrapping 설정
        for (const textureKey in groundTextures) {
            const texture = groundTextures[textureKey];
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
        }
        // 건물 텍스처 업데이트
        const buildingTextures = [
            loader.load('https://plus.unsplash.com/premium_photo-1673621329410-e4ef5df05b69?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8YnVpbGRpbmclMjB0ZXh0dXJlfGVufDB8fDB8fHww'),
            loader.load('https://plus.unsplash.com/premium_photo-1676218886284-bca308235404?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8OXx8YnVpbGRpbmclMjB0ZXh0dXJlfGVufDB8fDB8fHww'),
            loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTXBDLtmLJvwiGqzxaw20jjDnRFxXslwwHelw&s'),
            loader.load('https://plus.unsplash.com/premium_photo-1672265517508-52bbda78e263?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8NTd8fGJ1aWxkaW5nJTIwdGV4dHVyZXxlbnwwfHwwfHx8MA%3D%3D'),
            loader.load('https://images.unsplash.com/photo-1612365009551-0abb42a5f096?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Nzh8fGJ1aWxkaW5nJTIwdGV4dHVyZXxlbnwwfHwwfHx8MA%3D%3D'),
            loader.load('https://images.unsplash.com/photo-1597764868510-294f99cbad63?w=800&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTM3fHxidWlsZGluZyUyMHRleHR1cmV8ZW58MHx8MHx8fDA%3D')
        ];
        // 도로 텍스처 업데이트
        const roadTexture = loader.load('https://search.pstatic.net/sunny/?src=https%3A%2F%2Fstatic3.depositphotos.com%2F1003789%2F185%2Fi%2F450%2Fdepositphotos_1854911-stock-photo-asphalt-texture.jpg&type=a340');
        roadTexture.wrapS = THREE.RepeatWrapping;
        roadTexture.wrapT = THREE.RepeatWrapping;
        roadTexture.repeat.set(10, 1);

        // 클릭 이벤트 리스너 추가
        window.addEventListener('click', onMouseClick, false);

        function onMouseClick(event) {
            // 마우스 좌표를 정규화된 장치 좌표(NDC)로 변환
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Raycaster 설정
            raycaster.setFromCamera(mouse, camera);

            // 충돌 감지
            const intersects = raycaster.intersectObjects(scene.children);

            // 교차된 객체가 있는 경우
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object; // 클릭된 첫 번째 객체
                const position = intersectedObject.position; // 클릭된 객체의 좌표
                console.log(`Clicked position: x=${position.x}, y=${position.y}, z=${position.z}`);
            }
        }


        class Chunk {
            constructor(x, z, size) {
                this.x = x * size;  // 절대 좌표로 설정
                this.z = z * size;
                this.size = size;
                this.roadWidth = 2; // 도로 두께
                this.mesh = new THREE.Group(); // 청크 내 여러 Mesh를 그룹으로 관리
                this.buildings = [];
                this.cars = [];
                // 도로 및 교차로 배치(intersection 만들기 위해 사용)
                this.roadPositionsX = [];
                this.roadPositionsZ = [];
                // 도로 경계를 저장할 배열
                this.roadsL = [];
                this.roadsR = [];
                this.roadsT = [];
                this.roadsB = [];
                this.roadmesh= [];
                //4개의 교차로를 저장할 배열
                this.intersectionRB= new Set();//roadsR, roadsB를 비교
                this.intersectionRT= new Set();
                this.intersectionLB= new Set();
                this.intersectionLT= new Set();
                this.intersectionRR= new Set();
                this.intersectionLL= new Set();
                this.generatepoints= [];
                this.label = this.getRandomLabel(); // 랜덤 라벨 생성
                this.buildingColor = buildingAreaColors[this.label]; // 라벨에 따른 건물 색상
                
                this.buildings = [];  // 건 위치와 크기를 저장하는 배열
                this.generateChunk();
                
            }
            getRandomLabel() {
                const random = Math.random();
                if (random < 0.05) return ZONE_TYPES.PARK;
                if (random < 0.50) return ZONE_TYPES.RESIDENTIAL;
                return ZONE_TYPES.COMMERCIAL;
            }
            // 랜덤 라벨을 반환하는 함수 (0 ~ 3)
            getRandomLabel() {
                return Math.floor(Math.random() * 4);
            }
            // 청크 생성
            generateChunk() {
                // 상하좌우 도로 생성
                this.createBorderRoads();
                
                // 청크를 꽉 채우는 건물 밀집 구역 생성
                this.fillWithBuildingAreas();
                
                //교차로 생성
                this.createIntersections();

                //도로위에 차 생성
                this.createCars(10);

                //건물생성

            }

            // 상하좌우 도로를 생성하는 함수
            createBorderRoads() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: roadColor });
                roadMaterial.receiveShadow = true;
                // 상단 도로
                let roadGeometry = new THREE.PlaneGeometry(this.size, this.roadWidth);
                roadGeometry.rotateX(-Math.PI / 2);
                let road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(this.x + this.size / 2, 0.1, this.z + this.size - this.roadWidth / 2);
                this.mesh.add(road);

                // 하단 도로
                road = road.clone();
                road.position.set(this.x + this.size / 2, 0.1, this.z + this.roadWidth / 2);
                this.mesh.add(road);

                // 좌측 도로
                roadGeometry = new THREE.PlaneGeometry(this.roadWidth, this.size);
                roadGeometry.rotateX(-Math.PI / 2);
                road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(this.x + this.roadWidth / 2, 0.1, this.z + this.size / 2);
                this.mesh.add(road);

                // 우측 도로
                road = road.clone();
                road.position.set(this.x + this.size - this.roadWidth / 2, 0.1, this.z + this.size / 2);
                this.mesh.add(road);
            }

            // 청크를 꽉 채우는 건물 밀집 구역을 반복해서 생성
            fillWithBuildingAreas() {
                const buildingAreaMaterial = new THREE.MeshPhongMaterial({ 
                    map: groundTextures[this.label],
                    side: THREE.DoubleSide
                });
                const roadMaterial = new THREE.MeshLambertMaterial({ color: roadColor });
                const roadWidth = this.roadWidth;

                let currentX = this.x + roadWidth;
                let currentZ = this.z + roadWidth;
                // 5개의 랜덤한 X 크기 생성 (건물 너비)
                const xValues = this.generateRandomSizes(this.size - 2 * roadWidth, 5, 40, 100);

                // X축을 따라 건물 배치
                for (let i = 0; i < xValues.length; i++) {
                    const xWidth = xValues[i];
                    currentZ = this.z+ roadWidth;  // Z축을 다시 처음 위치로 리셋

                    // 5개의 랜덤한 Z 크기 생성 (건물 깊이)
                    const zValues = this.generateRandomSizes(this.size - 2 * roadWidth, 5, 40, 100);
                    // Z축을 따라 건물 배치
                    for (let j = 0; j < zValues.length; j++) {
                        const zDepth = zValues[j];

                        // 도로를 그리는 함수 호출
                        this.createRoads(currentX+roadWidth, currentZ, xWidth, zDepth, roadWidth, roadMaterial);

                        // 건물 밀집 구역 생성
                        const buildingAreaGeometry = new THREE.PlaneGeometry(xWidth - 2 * roadWidth, zDepth - 2 * roadWidth);
                        buildingAreaGeometry.rotateX(-Math.PI / 2); // 평면을 위로 돌림
                        const buildingArea = new THREE.Mesh(buildingAreaGeometry, buildingAreaMaterial);
                        buildingArea.position.set(currentX + xWidth / 2, 0.1, currentZ + zDepth / 2);
                        this.mesh.add(buildingArea);
                        // 건물 생성
                        this.createBuildingArea(currentX+roadWidth, currentZ+roadWidth, xWidth-4, zDepth-4);

                        currentZ += zDepth; // 다음 Z축으로 이동
                    }

                    currentX += xWidth; // 다음 X축으로 이동
                }
            }
            createRoads(x, z, width, depth, roadWidth, roadMaterial) {
                const roadGeometryX = new THREE.PlaneGeometry(width, roadWidth);  // 가로 도로용
                const roadGeometryZ = new THREE.PlaneGeometry(roadWidth, depth-2*roadWidth);  // 세로 도로용
                const roadMaterialWithTexture = new THREE.MeshPhongMaterial({ 
                    map: roadTexture,
                    side: THREE.DoubleSide 
                });
                roadGeometryX.rotateX(-Math.PI / 2);
                roadGeometryZ.rotateX(-Math.PI / 2);
            
                // 상단 도로
                const topRoad = new THREE.Mesh(roadGeometryX, roadMaterial);
                topRoad.position.set(x + width / 2-roadWidth, 0.1, z + depth - roadWidth / 2);
                topRoad.geometry.computeBoundingBox();  // boundingBox 계산
                this.mesh.add(topRoad);
                this.roadsT.push({ x:(x + width / 2-roadWidth), z:z + depth - roadWidth / 2, width: width, depth: depth,f:width });
                this.roadmesh.push(topRoad);
                

                // 하단 도로
                const bottomRoad = new THREE.Mesh(roadGeometryX, roadMaterial);
                bottomRoad.position.set(x + width / 2-roadWidth, 0.1, z + roadWidth / 2);
                bottomRoad.geometry.computeBoundingBox();  // boundingBox 계산
                this.mesh.add(bottomRoad);
                this.roadsB.push({x:x + width / 2-roadWidth, z: z + roadWidth / 2, width: width, depth: depth,f:width,f:width});
                this.roadmesh.push(bottomRoad);
                

                // 좌측 도로
                const leftRoad = new THREE.Mesh(roadGeometryZ, roadMaterial);
                leftRoad.position.set(x + width - 3*roadWidth/2, 0.1, z + depth / 2);
                leftRoad.geometry.computeBoundingBox();  // boundingBox 계산
                this.mesh.add(leftRoad);
                this.roadsL.push({x:x + width - 3*roadWidth/2, z: z + depth / 2, width: width, depth: depth,f:depth-2*roadWidth});
                this.roadmesh.push(leftRoad);
                

                // 우측 도로
                const rightRoad = new THREE.Mesh(roadGeometryZ, roadMaterial);
                rightRoad.position.set(x - roadWidth / 2, 0.1, z + depth / 2);
                rightRoad.geometry.computeBoundingBox();  // boundingBox 계산
                this.mesh.add(rightRoad);
                this.roadsR.push({x:x - roadWidth / 2, z: z + depth / 2, width: width, depth: depth,f:depth-2*roadWidth});
                this.roadmesh.push(rightRoad);
                

            }

            // 교차로 생성 함수
            createIntersections() {
                const intersectionMaterial = new THREE.MeshLambertMaterial({ color:roadColor });
                const intersectionGeometry = new THREE.BoxGeometry(this.roadWidth, 0.1, this.roadWidth);

                for (let r of this.roadsR){
                    for(let t of this.roadsT){
                        
                        if(r.x+this.roadWidth/2 == t.x - t.width/2 + this.roadWidth){
                            
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(r.x,0.1,r.z+r.depth/2+this.roadWidth/2-this.roadWidth);
                            this.mesh.add(intersection);
                            this.intersectionRT.add(intersection);
                        }
                    }
                }
                for (let r of this.roadsR){
                    for(let b of this.roadsB){
                        if(r.x+this.roadWidth/2 == b.x - b.width/2 + this.roadWidth){
                            const intersection = new THREE.Mesh(intersectionGeometry,intersectionMaterial);
                            intersection.position.set(r.x,0.1,r.z-r.depth/2+this.roadWidth/2);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionRB.add(intersection);
                        }
                    }
                }
                for (let l of this.roadsL){
                    for(let b of this.roadsB){
                        if(l.x-l.width+3*this.roadWidth/2 == b.x-b.width/2 + this.roadWidth){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(l.x,0.1,l.z-l.depth/2-this.roadWidth/2+this.roadWidth);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionLB.add(intersection);
                        }
                    }
                }
                for (let l of this.roadsL){
                    for(let t of this.roadsT){
                        if(t.x - t.width/2 + this.roadWidth == l.x-l.width+3*this.roadWidth/2){
                            const intersection = new THREE.Mesh(intersectionGeometry,intersectionMaterial);
                            intersection.position.set(l.x,0.1,l.z-l.depth/2+-this.roadWidth/2+l.depth);
                            this.mesh.add(intersection);
                            
                            this.intersectionLT.add(intersection);
                        }
                    }
                }

                
                
                for (let rT of this.roadsR){
                    for(let rB of this.roadsR){
                        if(rT.z-rT.depth/2 == rB.z+rB.depth/2){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(rT.x-this.roadWidth,0.1,rB.z+rB.depth/2-this.roadWidth/2);
                            this.mesh.add(intersection);
                            
                            this.intersectionRR.add(intersection);
                        }
                    }
                }
                for (let lT of this.roadsL){
                    for(let lB of this.roadsL){
                        if(lT.z-lT.depth/2 == lB.z+lB.depth/2){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(lT.x+this.roadWidth,0.1,lB.z+lB.depth/2+this.roadWidth/2);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionLL.add(intersection);
                        }
                    }
                }
                this.generatepoint = this.generatePointsFromRoads()
            }

            

            generateRandomSizes(sum, count, min, max) {
                const sizes = [];
                let total = 0;
            
                // 값들을 먼저 min으로 채우고, 그 다음으로 남은 값을 분배
                for (let i = 0; i < count; i++) {
                    sizes.push(min);
                    total += min;
                }
            
                let remaining = sum - total;
            
                // 남은 값을 랜덤하게 각 사이즈에 분배 (정수로 처리)
                while (remaining > 0) {
                    for (let i = 0; i < count && remaining > 0; i++) {
                        const add = Math.min(remaining, Math.floor(Math.random() * (max - min + 1)));
                        sizes[i] += add;
                        remaining -= add;
                    }
                }
            
                return sizes;
            }
            createCars(numberOfCars){
                for(let i=0;i<numberOfCars;i++){

                    //0이면 rightroads
                    //1이면 leftroads
                    //2이면 toproads
                    //3이면 bottomroads
                    const roadIndex = Math.floor(Math.random()*4);
                    
                    
                    if(roadIndex==0){
                        //roadsR[]에서 랜덤으로 하나
                        const randomElement = this.roadsR[Math.floor(Math.random() * this.roadsR.length)];
                        const car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 2), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z); 
                        car.direction = 'south'; 
                        this.cars.push(car);
                        this.mesh.add(car);                       
                    } else if(roadIndex==1){
                        //roadsL[]에서      으로 하나
                        const randomElement = this.roadsL[Math.floor(Math.random() * this.roadsL.length)];
                        const car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 2), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z); 
                        car.direction = 'north'; 
                        this.cars.push(car);
                        this.mesh.add(car);
                    } else if(roadIndex==2){
                        const randomElement = this.roadsT[Math.floor(Math.random()* this.roadsT.length)];
                        const car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 2), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z);
                        car.direction = 'east';
                        this.cars.push(car);
                        this.mesh.add(car);
                    }else{
                        const randomElement = this.roadsB[Math.floor(Math.random()* this.roadsB.length)];
                        const car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 2), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z);
                        car.direction = 'west';

                        this.cars.push(car);
                        this.mesh.add(car);
                        //console.log(this.cars);
                    }
                    //console.log(this.cars);
                }
            }
            animateCar(){
                this.cars.forEach(car => {
                    
                    
                    if(car.direction=='north'){
                        car.position.z += 0.4;
                        
                    } else if(car.direction=='south'){
                        car.position.z -= 0.4;
                        
                    } else if(car.direction=='west'){
                        car.position.x += 0.4;
                        
                    } else{
                        car.position.x -= 0.4;
                    }
                    
                    if (!scene.getObjectById(car.id)) {
                        console.log(`Car with ID ${car.id} is missing from the scene.`);
                    }
                    // 교차로에 도달했는지 확인 (정확한 교차로 좌표와 비교)
                    
                    for(let intersection of this.intersectionLB){
                        
                        if(intersection.position.distanceTo(car.position)<0.6){
                            car.position.x = intersection.position.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.position.z;  // 교차로 중심으로 위치 보정
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            //console.log("lb");
                            //console.log(car.position);
                            const direction = this.chooseDirectionAtIntersection(intersection, car.direction,"LB");
                            car.direction = direction;
                            //console.log("2");
                            //console.log(car.direction);
                            //console.log(car.position);
                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.z += this.roadWidth+ 0.1;
                                    break;
                                case 'south':
                                    car.position.x += this.roadWidth;
                                    car.position.z -= 2*this.roadWidth;
                                    break;
                                case 'east':
                                    //car.position.x += 0.5;
                                    break;
                                case 'west':
                                    car.position.x += 2*this.roadWidth;
                                    break;
                            }   
                        }
                    }
                    
                    for(let intersection of this.intersectionLT){
                        
                        
                        if(intersection.position.distanceTo(car.position)<1){
                            car.position.x = intersection.position.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.position.z;  // 교차로 중심으로 위치 보정
                            //console.log("LT");
                            //console.log(car.position);
                            
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            
                            const direction = this.chooseDirectionAtIntersection(intersection, car.direction,"LT");
                            
                            //console.log(direction);
                            car.direction = direction;
                            //console.log("2");
                            //console.log(car.direction);
                            //console.log(car.position);
                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.z += 2*this.roadWidth+0.5;
                                
                                    break;
                                case 'south':
                                    //car.position.z -= 2*this.roadWidth;
                                    //car.position.x -= this.roadWidth;
                                    break;
                                case 'east':
                                    car.position.x -= this.roadWidth -0.5;
                                    break;
                                case 'west':
                                    car.position.z -= this.roadWidth+0.5;
                                    car.position.x += this.roadWidth+0.5;
                                    break;
                            }   
                        }
                    }
                    
                    for(let intersection of this.intersectionRB){
                        if(intersection.position.distanceTo(car.position)<1){
                            car.position.x = intersection.position.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.position.z;  // 교차로 중심으로 위치 보정
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            //console.log("rb");
                            //console.log(car.position);
                            const direction = this.chooseDirectionAtIntersection(intersection, car.direction,"RB");
                            car.direction = direction;
                            //console.log("2");
                            //console.log(car.direction);
                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.z += 0.1;
                                    break;
                                case 'south':
                                    car.position.z -= this.roadWidth+0.1;
                                    
                                    break;
                                case 'east':
                                    car.position.x += this.roadWidth+0.1;
                                    break;
                                case 'west':
                                    car.position.x += this.roadWidth;
                                    break;
                            }   
                        }
                    }
                    
                    for(let intersection of this.intersectionRT){
                        if(intersection.position.distanceTo(car.position)<1){
                            car.position.x = intersection.position.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.position.z;  // 교차로 중심으로 위치 보정
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            //console.log("rt");
                            //console.log(car.position);
                            let direction = this.chooseDirectionAtIntersection(intersection, car.direction,"RT");
                            car.direction = direction;
                            //console.log("2");
                            //console.log(car.direction);
                            //console.log(car.position);
                            
                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.x -= this.roadWidth;
                                    car.position.z += 2*this.roadWidth;
                                    //console.log(car.position);
                                    break;
                                case 'south':
                                    car.position.z -= this.roadWidth+0.1;
                                    //console.log(car.position);
                                    break;
                                case 'east':
                                    car.position.x -= 2*this.roadWidth-0.1;
                                    //console.log(car.position);
                                    break;
                                case 'west':
                                    //car.position.x -= 2*this.roadWidth;
                                    break;
                            }   
                        }
                    }
                    
                    for(let intersection of this.intersectionRR){
                        if(intersection.position.distanceTo(car.position)<1){
                            car.position.x = intersection.position.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.position.z;  // 교차로 중심으로 위치 보정
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            //console.log("RR");
                            //console.log(car.position);
                            const direction = this.chooseDirectionAtIntersection(intersection, car.direction,"RR");
                            car.direction = direction;             
                           //console.log("2");
                            //console.log(car.direction);
                            //console.log(car.position);
                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.z += this.roadWidth+0.1;
                                    break;
                                case 'south':
                                    car.position.z -= this.roadWidth+0.1;
                                    car.position.x += this.roadWidth;
                                    break;
                                case 'east':
                                    car.position.x += this.roadWidth+0.1;
                                    break;
                                case 'west':
                                    car.position.z += this.roadWidth;
                                    car.position.x += 2*this.roadWidth;
                                    break;
                            }   
                        }
                    }
                    
                    for(let intersection of this.intersectionLL){
                        if(intersection.position.distanceTo(car.position)<1){
                            car.position.x = intersection.position.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.position.z;  // 교차로 중심으로 위치 보정
                            //console.log("LL");
                            //console.log(car.position);
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            const direction = this.chooseDirectionAtIntersection(intersection, car.direction,"LL");
                            car.direction = direction;
                            //console.log("2");
                            //console.log(car.direction);
                            //console.log(car.position);
                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.z += 0.1;
                                    break;
                                case 'south':
                                    car.position.z -= this.roadWidth+0.1;
                                    
                                    break;
                                case 'east':
                                    car.position.x -= 2*this.roadWidth+0.1;
                                    car.position.z -= this.roadWidth
                                    break;
                                case 'west':
                                    car.position.z += this.roadWidth;
                                    car.position.x += 0.1;
                                    break;
                            }   
                        }
                    }
                    
                    

                });
                
            
            
            }
            generatePointsFromRoads() {
                const points = [];
                const meshMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // 빨간색 material
                
                // roadsR 배열 처리
                this.roadsR.forEach(road => {
                    const x = road.x;
                    const z = road.z;
                    const f = road.f;
                    // 두 점 계산
                    const point1 = new THREE.Vector3(x, 0.1, z - f/2+ this.roadWidth/2 );
                    const point2 = new THREE.Vector3(x, 0.1, z + f/2-this.roadWidth/2 );
                    const point3 = new THREE.Vector3(x-this.roadWidth, 0.1,z + f/2- this.roadWidth/2);
                    const point4 = new THREE.Vector3(x-this.roadWidth, 0.1,z - f/2+ this.roadWidth/2 );
                    points.push(point1, point2);
                    points.push(point3, point4);
                    // 두 점에 해당하는 Mesh 생성
                    this.addMeshAtPoint(point1, meshMaterial);
                    this.addMeshAtPoint(point2, meshMaterial);
                    this.addMeshAtPoint(point3, meshMaterial); 
                    this.addMeshAtPoint(point4, meshMaterial);
                });
            
                // roadsL 배열 처리
                this.roadsL.forEach(road => {
                    const x = road.x;
                    const z = road.z;
                    const f = road.f;
                    // 두 점 계산
                    const point1 = new THREE.Vector3(x, 0.1, z - f/2+ this.roadWidth/2 );
                    const point2 = new THREE.Vector3(x, 0.1, z + f/2-this.roadWidth/2 );
                    const point3 = new THREE.Vector3(x+this.roadWidth, 0.1,z - f/2+ this.roadWidth/2 );
                    const point4 = new THREE.Vector3(x+this.roadWidth, 0.1,z + f/2- this.roadWidth/2 );
                    points.push(point1, point2);
                    points.push(point3, point4);
                    // 두 점에 해당하는 Mesh 생성
                    this.addMeshAtPoint(point1, meshMaterial);
                    this.addMeshAtPoint(point2, meshMaterial);
                    this.addMeshAtPoint(point3, meshMaterial);
                    this.addMeshAtPoint(point4, meshMaterial);
                });
            
                // roadsT 배열 처리
                this.roadsT.forEach(road => {
                    const x = road.x;
                    const z = road.z;
                    const f = road.f;
                    // 두 점 계산
                    const point1 = new THREE.Vector3(x - f/2+this.roadWidth+this.roadWidth/2 , 0.1, z);
                    const point2 = new THREE.Vector3(x + f/2-this.roadWidth-this.roadWidth/2 , 0.1, z);
                    points.push(point1, point2);
                    
                    // 두 점에 해당하는 Mesh 생성
                    this.addMeshAtPoint(point1, meshMaterial);
                    this.addMeshAtPoint(point2, meshMaterial);
                });
            
                // roadsB 배열 처리
                this.roadsB.forEach(road => {
                    const x = road.x;
                    const z = road.z;
                    const f = road.f;
                    // 두 점 계산
                    const point1 = new THREE.Vector3(x - f/2+this.roadWidth+this.roadWidth/2  , 0.1, z);
                    const point2 = new THREE.Vector3(x + f/2-this.roadWidth-this.roadWidth/2 , 0.1, z);
                    points.push(point1, point2);
                    
                    // 두 점에 해당하는 Mesh 생성
                    this.addMeshAtPoint(point1, meshMaterial);
                    this.addMeshAtPoint(point2, meshMaterial);
                });
            
                return points;
            }
            
            addMeshAtPoint(point, material) {
                const geometry = new THREE.BoxGeometry(1, 0.1, 1); // 크기 0.4, 0.1, 0.4의 박스 생성
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(point); // point 좌표로 mesh 위치 설정

            }
            
            
            // 도로가 있는지 확인하는 함수
            checkRoadDirection(intersection,intersectiondirection) {
                
                let possibleDirections = [];
                let roadWidth = this.roadWidth;
                // 교차로 기준 좌표
                const x = intersection.position.x;
                const z = intersection.position.z;
                const roads = this.generatepoint;
                
                //console.log(intersection)
                //console.log(intersectiondirection)
                if(intersectiondirection == "LB"){
                    
                        //만약 LB이라면
                    // 각 도로가 포함되는지 확인하는 좌표
                    const topCheck = new THREE.Vector3(x, 0.1, z + roadWidth);
                    const bottomCheck = new THREE.Vector3(x+roadWidth, 0.1, z - 2*roadWidth);
                    const leftCheck = new THREE.Vector3(x + 2*roadWidth, 0.1, z);
                    
                    //console.log(topCheck);
                    //console.log(bottomCheck);
                    //console.log(leftCheck);
                    // 도로에 포함되어 있는지 검사

                    roads.forEach(road => {
                        
                        if (road.distanceToSquared(topCheck)<0.000001) {
                            possibleDirections.push('north');
                        }
                        if (road.distanceToSquared(bottomCheck)<0.000001) {
                            possibleDirections.push('south');
                        }
                        if (road.distanceToSquared(leftCheck)<0.000001) {
                            possibleDirections.push('west');
                        }
                    });
                }else if(intersectiondirection == "LT"){
                    
                    //만약 LT이라면
                    // 각 도로가 포함되는지 확인하는 좌표
                    const topCheck = new THREE.Vector3(x, 0.1, z + 2* roadWidth);
                    //const bottomCheck = new THREE.Vector3(x-roadWidth, 0, z - roadWidth);
                    const leftCheck = new THREE.Vector3(x +2* roadWidth, 0.1, z+roadWidth);
                    const rightCheck = new THREE.Vector3(x-roadWidth,0.1,z);
                    //console.log(topCheck);
                    //console.log(rightCheck);
                    //console.log(leftCheck);
                    // 도로에 포함되어 있는지 검사
                    roads.forEach(road => {
                        if (road.distanceToSquared(topCheck)<0.000001) {
                            possibleDirections.push('north');
                        }
                        if (road.distanceToSquared(rightCheck)<0.000001) {
                            possibleDirections.push('east');
                        }
                        if (road.distanceToSquared(leftCheck)<0.000001) {
                            possibleDirections.push('west');
                        }
                        
                    }); 
                }else if(intersectiondirection == "RB"){
                    
                        //만약 RB이라면
                    // 각 도로가 포함되는지 확인하는 좌표
                    //const topCheck = new THREE.Vector3(x+roadWidth, 0, z + roadWidth);
                    const bottomCheck = new THREE.Vector3(x, 0.1, z - 2*roadWidth);
                    const leftCheck = new THREE.Vector3(x + roadWidth, 0.1, z);
                    const rightCheck = new THREE.Vector3(x-2*roadWidth,0.1,z-roadWidth);
                    //console.log(rightCheck);
                    //console.log(bottomCheck);
                    //console.log(leftCheck);
                    // 도로에 포함되어 있는지 검사
                    roads.forEach(road => {
                        
                        if (road.distanceToSquared(bottomCheck)<0.000001) {
                            possibleDirections.push('south');
                        }
                        if (road.distanceToSquared(rightCheck)<0.000001) {
                            possibleDirections.push('east');
                        }
                        if (road.distanceToSquared(leftCheck)<0.000001) {
                            possibleDirections.push('west');
                        }
                    });
                }else if(intersectiondirection == "RT"){
                    
                        //만약 RT이라면
                    // 각 도로가 포함되는지 확인하는 좌표
                    const topCheck = new THREE.Vector3(x-roadWidth, 0.1, z +2* roadWidth);
                    const bottomCheck = new THREE.Vector3(x, 0.1, z - roadWidth);
                    //const leftCheck = new THREE.Vector3(x , 0, z+2*roadWidth);
                    const rightCheck = new THREE.Vector3(x-2*roadWidth,0.1,z);
                    //console.log(topCheck);
                    //console.log(bottomCheck);
                    //console.log(rightCheck);

                    // 도로에 포함되어 있는지 검사
                    roads.forEach(road => {
                        
                        if (road.distanceToSquared(topCheck)<0.000001) {
                            possibleDirections.push('north');
                        }
                        if (road.distanceToSquared(bottomCheck)<0.000001) {
                            possibleDirections.push('south');
                        }
                        if (road.distanceToSquared(rightCheck)<0.000001) {
                            possibleDirections.push('east');
                        }
                
                });
                }
                else if(intersectiondirection == "RR"){
                    possibleDirections.push('north');
                    possibleDirections.push('west');

                
                }
                else if(intersectiondirection == "LL"){
                    possibleDirections.push('south');
                    possibleDirections.push('east');
                    
                    
                }
                

                return possibleDirections;
            }
            // 교차로에서 갈 수 있는 방향을 확인하는 함수
            chooseDirectionAtIntersection(intersection, currentDirection,intersectiondirection) {
                
                const possibleDirections = this.checkRoadDirection(intersection,intersectiondirection);
                //console.log(possibleDirections);

                // 선택할 수 있는 방향 중 랜덤으로 하나 선택
                return possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
            }
            
            createBuildingArea(regionX, regionZ, regionWidth, regionDepth) {
                const zoneType = this.getRandomLabel();

                if (zoneType === ZONE_TYPES.PARK) {
                    // 공원 구역 생성
                    const parkGeometry = new THREE.PlaneGeometry(regionWidth, regionDepth);
                    const parkMaterial = new THREE.MeshPhongMaterial({ 
                        map: groundTextures[ZONE_TYPES.PARK],
                        side: THREE.DoubleSide 
                    });
                    
                    const park = new THREE.Mesh(parkGeometry, parkMaterial);
                    park.rotation.x = -Math.PI / 2;
                    park.position.set(
                        regionX + regionWidth / 2,
                        0.1,
                        regionZ + regionDepth / 2
                    );
                    this.mesh.add(park);

                    // 호수 추가
                    const lakeGeometry = new THREE.CircleGeometry(Math.min(regionWidth, regionDepth) * 0.2, 32);
                    const lakeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x4169E1,
                        opacity: 0.8,
                        transparent: true
                    });
                    const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                    lake.rotation.x = -Math.PI / 2;
                    lake.position.set(
                        regionX + regionWidth / 2,
                        0.2,
                        regionZ + regionDepth / 2
                    );
                    this.mesh.add(lake);
                } else {
                    // 주거/상업 구역 생성
                    const areaGeometry = new THREE.PlaneGeometry(regionWidth, regionDepth);
                    const areaMaterial = new THREE.MeshPhongMaterial({ 
                        map: groundTextures[zoneType],
                        side: THREE.DoubleSide 
                    });
                    const area = new THREE.Mesh(areaGeometry, areaMaterial);
                    area.rotation.x = -Math.PI / 2;
                    area.position.set(
                        regionX + regionWidth / 2,
                        0.1,
                        regionZ + regionDepth / 2
                    );
                    this.mesh.add(area);

                    // 인도 경로 생성
                    const sidewalkX = this.generateRandomSizessidePosition(regionX, regionWidth);
                    const sidewalkZ = this.generateRandomSizessidePosition(regionZ, regionDepth);
                    
                    // X축 인도 배치
                    sidewalkX.forEach((xPos) => {
                        const sidewalk = this.createSidewalk(xPos, regionZ, regionDepth, 'z');
                        this.mesh.add(sidewalk);
                    });

                    // Z축 인도 배치
                    sidewalkZ.forEach((zPos) => {
                        const sidewalk = this.createSidewalk(regionX, zPos, regionWidth, 'x');
                        this.mesh.add(sidewalk);
                    });

                    // 건물 배치 (구역 타입에 따라 다른 높이 적용)
                    this.placeBuildings(
                        regionX, 
                        regionZ, 
                        regionWidth, 
                        regionDepth, 
                        sidewalkX, 
                        sidewalkZ,
                        zoneType  // 구역 타입 전달
                    );
                }
            }
        
            
            generateRandomSizessidePosition(start, length) {
                //console.log(start, length);
                let min=2
                let max=3
                let count = Math.floor(Math.random() * (max-min))+min;
                while(length-10*(count+1)<0){
                    count--;
                }
                //console.log("count");
                //console.log(count); 
                const sizes = [];
                let total = 0;
                min = 10;
                
                
                let sum = length;
                // 값들을 먼저 min으로 채우고, 그 다음으로 남은 값을 분배
                for (let i = 0; i < count; i++) {
                    sizes.push(min);
                    total += min;
                }
                
                let remaining = Math.round(sum - total)-min;
                max = Math.round(remaining/(count+1));
                min = Math.round(max/2);
                // 남은 값을 랜덤하게 각 사이즈에 분배 (정수로 처리)
                total =0;;
                for (let i = 0; i < count ; i++) {
                    const add = Math.min(remaining, Math.floor(Math.random() * (max))+min);
                    total+=add;
                    sizes[i] += add;
                    remaining -= add;
                }
                

                
                 // updatedPositions을 누적 좌표로 변환
                let currentPosition = start;
                let finalPosition=[];
                finalPosition.push(start);
                
                for (const size of sizes ) {
                    currentPosition += size;
                    finalPosition.push(currentPosition);
                }
                finalPosition.push(start+length-1);
                return finalPosition;
            }
            
        
            // 인도 Mesh 생성
            createSidewalk(x, z, length, axis) {
                const geometry = axis === 'x' ? new THREE.PlaneGeometry(length, 1) : new THREE.PlaneGeometry(1, length);
                const material = new THREE.MeshLambertMaterial({ color: 0xd3d3d3 });
                const sidewalk = new THREE.Mesh(geometry, material);
                if (axis === 'x') {
                    sidewalk.position.set(x + length / 2, 0.2, z + 1/ 2);
                } else {
                    sidewalk.position.set(x + 1/2, 0.2, z + length / 2);
                }
                sidewalk.rotateX(-Math.PI / 2);
                return sidewalk;
            }
        
            // 남은 공간에 건물 생성
            placeBuildings(regionX, regionZ, regionWidth, regionDepth, sidewalksX, sidewalksZ, zoneType) {
                let xValues = sidewalksX;
                let zValues = sidewalksZ;
                
                for (let i = 0; i < xValues.length - 1; i++) {
                    for (let j = 0; j < zValues.length - 1; j++) {
                        if (Math.random() > 0.3) {  // 70% 확률로 건물 생성
                            const width = Math.abs(xValues[i + 1] - xValues[i]);
                            const depth = Math.abs(zValues[j + 1] - zValues[j]);
                            
                            // 구역 타입에 따른 건물 높이 설정
                            let height;
                            if (zoneType === ZONE_TYPES.RESIDENTIAL) {
                                height = Math.random() * 20 + 15;  // 15-35 높이
                            } else {  // COMMERCIAL
                                height = Math.random() * 60 + 40;  // 40-100 높이
                            }

                            this.createBuilding(
                                xValues[i] + width/2,
                                zValues[j] + depth/2,
                                width,
                                height,
                                depth,zoneType
                            );
                        }
                    }
                }
            }
        
            createBuilding(x, z, width, height, depth, zoneType) {
                const geometry = new THREE.BoxGeometry(width-4, height, depth-4);
                
                // 건물 타입에 따른 텍스처 선택
                const textureIndex = Math.floor(Math.random() * buildingTextures.length);
                const buildingTexture = buildingTextures[textureIndex];
                
                // 텍스처 설정
                buildingTexture.wrapS = THREE.RepeatWrapping;
                buildingTexture.wrapT = THREE.RepeatWrapping;
                buildingTexture.repeat.set(1, Math.ceil(height / 10));  // 높이에 따라 반복 조정
                
                // 건물의 각 면에 대한 materials 생성
                const materials = [
                    new THREE.MeshPhongMaterial({ map: buildingTexture }), // right
                    new THREE.MeshPhongMaterial({ map: buildingTexture }), // left
                    new THREE.MeshPhongMaterial({ map: buildingTextures[2] }), // top
                    new THREE.MeshPhongMaterial({ map: buildingTexture }), // bottom
                    new THREE.MeshPhongMaterial({ map: buildingTexture }), // front
                    new THREE.MeshPhongMaterial({ map: buildingTexture })  // back
                ];

                const building = new THREE.Mesh(geometry, materials);
                building.position.set(x, height / 2 + 0.1, z);
                building.castShadow = true;
                building.receiveShadow = true;
                this.mesh.add(building);
            } 

            
            
        }   
class ChunkManager {
    constructor() {
        this.chunks = new Map(); // 청크 저장용 Map
        this.chunkSize = 500;
        this.maxChunks = 6;
        this.clouds = this.createClouds();
        this.clouds.visible = false;
    }

    getChunkCoord(position) {
        return Math.floor(position / this.chunkSize);
    }

    getChunkKey(x, z) {
        return `${x},${z}`;
    }

    getFurthestChunk(cameraX, cameraZ) {
        let maxDistance = -1;
        let furthestKey = null;
        
        this.chunks.forEach((chunk, key) => {
            const [x, z] = key.split(',').map(Number);
            const dx = (x * this.chunkSize + this.chunkSize/2) - cameraX;
            const dz = (z * this.chunkSize + this.chunkSize/2) - cameraZ;
            const distance = dx * dx + dz * dz;
            
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestKey = key;
            }
        });
        
        return furthestKey;
    }

    update(cameraX, cameraZ) {
        const centerX = this.getChunkCoord(cameraX);
        const centerZ = this.getChunkCoord(cameraZ);

        for (let x = centerX - 1; x <= centerX + 1; x++) {
            for (let z = centerZ - 1; z <= centerZ + 1; z++) {
                const key = this.getChunkKey(x, z);
                
                if (!this.chunks.has(key)) {
                    if (this.chunks.size >= this.maxChunks) {
                        const furthestKey = this.getFurthestChunk(cameraX, cameraZ);
                        const furthestChunk = this.chunks.get(furthestKey);
                        scene.remove(furthestChunk.mesh);
                        this.chunks.delete(furthestKey);
                    }
                    
                    const chunk = new Chunk(x, z, this.chunkSize);
                    this.chunks.set(key, chunk);
                    scene.add(chunk.mesh);
                }
            }
        }
    }

    updateCars() {
        this.chunks.forEach(chunk => {
            chunk.animateCar();
        });
    }

    // 구름 생성 함수
    createClouds() {
        const cloudGroup = new THREE.Group();
        const cloudMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.8
        });

        for (let i = 0; i < 20; i++) {
            const singleCloud = new THREE.Group();
            const numParts = Math.floor(Math.random() * 5) + 5;

            for (let j = 0; j < numParts; j++) {
                const size = Math.random() * 5 + 5;
                const cloudPartGeometry = new THREE.SphereGeometry(size, 32, 32);
                const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudMaterial);
                
                cloudPart.position.set(
                    (Math.random() - 0.5) * size * 2,
                    (Math.random() - 0.5) * size * 1.5,
                    (Math.random() - 0.5) * size * 2
                );
                
                singleCloud.add(cloudPart);
            }

            singleCloud.position.set(
                Math.random() * this.chunkSize - this.chunkSize / 2,
                Math.random() * 100 + 100,
                Math.random() * this.chunkSize - this.chunkSize / 2
            );

            const scale = Math.random() * 0.5 + 0.75;
            singleCloud.scale.set(scale, scale, scale);
            cloudGroup.add(singleCloud);
        }

        scene.add(cloudGroup);
        return cloudGroup;
    }

    // 날씨 생성 함수
    createWeather(isSnow) {
        const weatherGeometry = new THREE.BufferGeometry();
        const particles = new Float32Array(1000 * 3);

        for (let i = 0; i < particles.length; i += 3) {
            particles[i] = Math.random() * this.chunkSize - this.chunkSize / 2;
            particles[i + 1] = Math.random() * 500;
            particles[i + 2] = Math.random() * this.chunkSize - this.chunkSize / 2;
        }

        weatherGeometry.setAttribute('position', new THREE.BufferAttribute(particles, 3));
        const weatherMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: isSnow ? 2 : 0.5,
            transparent: true
        });

        const weather = new THREE.Points(weatherGeometry, weatherMaterial);
        scene.add(weather);
        weatherParticles.push(weather);
    }

    // 날씨 업데이트
    updateWeather() {
        weatherParticles.forEach(particleSystem => scene.remove(particleSystem));
        weatherParticles = [];

        const weatherTypes = ['clear', 'cloudy', 'rain', 'snow'];
        weatherState = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];

        switch (weatherState) {
            case 'clear':
                this.clouds.visible = false;
                break;
            case 'cloudy':
                this.clouds.visible = true;
                break;
            case 'rain':
                this.clouds.visible = true;
                this.createWeather(false);
                break;
            case 'snow':
                this.clouds.visible = true;
                this.createWeather(true);
                break;
        }

        const skyColors = {
            clear: 0x87CEEB,
            cloudy: 0xA9A9A9,
            rain: 0x708090,
            snow: 0xF0F8FF
        };
        scene.background = new THREE.Color(skyColors[weatherState]);
    }

    // 날씨 애니메이션
    animateWeather() {
        if (this.clouds.visible) {
            this.clouds.children.forEach(cloud => {
                cloud.position.x += 0.1;
                if (cloud.position.x > this.chunkSize / 2) {
                    cloud.position.x = -this.chunkSize / 2;
                }
            });
        }

        weatherParticles.forEach(particleSystem => {
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= 1;
                if (positions[i] < 0) positions[i] = 500;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        });
    }
}
        
        // Three.js 환경 설정
        let scene, camera, renderer, controls, chunkManager;

        function init() {
            // 씬 생성
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 하늘색 배경

            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(150, 150, 0);

            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls 추가
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 조명 설정
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
directionalLight.position.set(100, 200, 100);
directionalLight.castShadow = true;
scene.add(directionalLight);

// 그림자 설정
renderer.shadowMap.enabled = true;
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;

            // ChunkManager 초기화
            chunkManager = new ChunkManager();

            // 애니메이션 루프 시작
            animate();

            setInterval(() => chunkManager.updateWeather(), 30000); // 30초마다 날씨 변경
        }

        // 창 크기 변경 시 처리
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 애니메이션 루프 수정
        function animate() {
            requestAnimationFrame(animate);
            
            // 태양 위치 업데이트
            const time = Date.now() * 0.001;
            const dayDuration = 60;
            const angle = (time % dayDuration) / dayDuration * Math.PI * 2;
            sunPosition.set(Math.cos(angle), Math.sin(angle), 0);

            // 조명 업데이트
            const lightIntensity = Math.max(0, sunPosition.y);
            const skyColor = new THREE.Color().setHSL(0.6, 1, 0.6 * lightIntensity + 0.1);
            if (weatherState === 'clear') {
                scene.background = skyColor;
            }
            directionalLight.color.copy(skyColor);
            directionalLight.intensity = lightIntensity * 0.7 + 0.3;
            
            // 기존 업데이트
            chunkManager.update(camera.position.x, camera.position.z);
            chunkManager.updateCars();
            chunkManager.animateWeather();
            
            controls.update();
            renderer.render(scene, camera);
        }

        // 초기화 함수 호출
        init();
    </script>
</body>
</html>
